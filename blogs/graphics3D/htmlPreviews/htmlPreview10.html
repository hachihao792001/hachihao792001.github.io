<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<title>3D Engine</title>
</head>

<body style="text-align: center; background: #f0f0f0">
	<h1>3D Engine</h1>
	<canvas id="gameCanvas" width="400" height="300" style="border: 2px solid #aaa; background: #fff"></canvas>
	<script>
		class Vector3 {
			constructor(x = 0, y = 0, z = 0, w = 1) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
			}

			clone() {
				return new Vector3(this.x, this.y, this.z, this.w);
			}

			static add(vec1, vec2) {
				return new Vector3(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z);
			}
			static sub(vec1, vec2) {
				return new Vector3(vec1.x - vec2.x, vec1.y - vec2.y, vec1.z - vec2.z);
			}
			static mul(vec, value) {
				return new Vector3(vec.x * value, vec.y * value, vec.z * value);
			}
			static div(vec, value) {
				return new Vector3(vec.x / value, vec.y / value, vec.z / value);
			}
			static scale(vec1, vec2) {
				return new Vector3(vec1.x * vec2.x, vec1.y * vec2.y, vec1.z * vec2.z);
			}
			static dot(v1, v2) {
				return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
			}
			static cross(v1, v2) {
				let v = new Vector3(
					v1.y * v2.z - v1.z * v2.y,
					v1.z * v2.x - v1.x * v2.z,
					v1.x * v2.y - v1.y * v2.x);
				return v;
			}
			magnitude() {
				return Math.hypot(this.x, this.y, this.z);
			}
			normalize() {
				let length = this.magnitude();
				if (length === 0)
					return this;
				this.x /= length;
				this.y /= length;
				this.z /= length;
				return this;
			}

			mulMat4x4(m) {
				let x = this.x;
				let y = this.y;
				let z = this.z;
				let w = this.w;
				this.x = m.m[0][0] * x + m.m[0][1] * y + m.m[0][2] * z + m.m[0][3] * w;
				this.y = m.m[1][0] * x + m.m[1][1] * y + m.m[1][2] * z + m.m[1][3] * w;
				this.z = m.m[2][0] * x + m.m[2][1] * y + m.m[2][2] * z + m.m[2][3] * w;
				this.w = m.m[3][0] * x + m.m[3][1] * y + m.m[3][2] * z + m.m[3][3] * w;
			}
		}

		class Mat4x4 {
			constructor() {
				this.m = [
					[0, 0, 0, 0],
					[0, 0, 0, 0],
					[0, 0, 0, 0],
					[0, 0, 0, 0]
				];
			}

			static Projection(fov, h, w, zNear, zFar) {
				let fovMultiplier = 1.0 / Math.tan(fov * 0.5 / 180.0 * Math.PI);
				let matrix = new Mat4x4();
				matrix.m[0][0] = h / w * fovMultiplier;
				matrix.m[1][1] = fovMultiplier;
				matrix.m[2][2] = zFar / (zFar - zNear);
				matrix.m[2][3] = (-zNear * zFar) / (zFar - zNear);
				matrix.m[3][2] = 1.0;
				return matrix;
			}

			static Translation(x, y, z) {
				let matrix = new Mat4x4();
				matrix.m[0][0] = 1;
				matrix.m[1][1] = 1;
				matrix.m[2][2] = 1;
				matrix.m[3][3] = 1;
				matrix.m[0][3] = x;
				matrix.m[1][3] = y;
				matrix.m[2][3] = z;
				return matrix;
			}

			static Scale(x, y, z) {
				let matrix = new Mat4x4();
				matrix.m[0][0] = x;
				matrix.m[1][1] = y;
				matrix.m[2][2] = z;
				matrix.m[3][3] = 1;
				return matrix;
			}

			static RotationX(angle) {
				let radian = angle / 180.0 * Math.PI;
				let matrix = new Mat4x4();
				matrix.m[0][0] = 1;
				matrix.m[1][1] = Math.cos(radian);
				matrix.m[1][2] = Math.sin(radian);
				matrix.m[2][1] = -Math.sin(radian);
				matrix.m[2][2] = Math.cos(radian);
				matrix.m[3][3] = 1;
				return matrix;
			}

			static RotationY(angle) {
				let radian = angle / 180.0 * Math.PI;
				let matrix = new Mat4x4();
				matrix.m[0][0] = Math.cos(radian);
				matrix.m[0][2] = -Math.sin(radian);
				matrix.m[1][1] = 1;
				matrix.m[2][0] = Math.sin(radian);
				matrix.m[2][2] = Math.cos(radian);
				matrix.m[3][3] = 1;
				return matrix;
			}

			static RotationZ(angle) {
				let radian = angle / 180.0 * Math.PI;
				let matrix = new Mat4x4();
				matrix.m[0][0] = Math.cos(radian);
				matrix.m[0][1] = Math.sin(radian);
				matrix.m[1][0] = -Math.sin(radian);
				matrix.m[1][1] = Math.cos(radian);
				matrix.m[2][2] = 1;
				matrix.m[3][3] = 1;
				return matrix;
			}
		}

		class Triangle {
			constructor(vertices = []) {
				if (vertices.length == 0) {
					this.vertices = [];
					for (let i = 0; i < 3; i++) {
						this.vertices.push(new Vector3(0, 0, 0));
					}
				} else {
					this.vertices = vertices;
				}
			}

			clone() {
				let tri = new Triangle();
				for (let i = 0; i < this.vertices.length; i++)
					tri.vertices[i] = this.vertices[i].clone();
				return tri;
			}

			mulMat4x4(m) {
				for (let v of this.vertices) {
					v.mulMat4x4(m);
				}
			}
		}

		class Cube {
			constructor(pos, rotation, scale) {
				this.tris = [];
				this.pos = pos;
				this.rotation = rotation;
				this.scale = scale;
				this.generateInitialTriangles();
			}

			generateInitialTriangles() {
				// FRONT
				this.tris.push(new Triangle([
					new Vector3(-0.5, -0.5, -0.5),
					new Vector3(-0.5, 0.5, -0.5),
					new Vector3(0.5, 0.5, -0.5)]));
				this.tris.push(new Triangle([
					new Vector3(-0.5, -0.5, -0.5),
					new Vector3(0.5, 0.5, -0.5),
					new Vector3(0.5, -0.5, -0.5)]));

				// RIGHT
				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, -0.5),
					new Vector3(0.5, 0.5, -0.5),
					new Vector3(0.5, 0.5, 0.5)]));

				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, -0.5),
					new Vector3(0.5, 0.5, 0.5),
					new Vector3(0.5, -0.5, 0.5)]));

				// BACK
				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, 0.5),
					new Vector3(0.5, 0.5, 0.5),
					new Vector3(-0.5, 0.5, 0.5)]));

				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, 0.5),
					new Vector3(-0.5, 0.5, 0.5),
					new Vector3(-0.5, -0.5, 0.5)]));

				// LEFT
				this.tris.push(new Triangle([
					new Vector3(-0.5, -0.5, 0.5),
					new Vector3(-0.5, 0.5, 0.5),
					new Vector3(-0.5, 0.5, -0.5)]));

				this.tris.push(new Triangle([
					new Vector3(-0.5, -0.5, 0.5),
					new Vector3(-0.5, 0.5, -0.5),
					new Vector3(-0.5, -0.5, -0.5)]));

				// TOP
				this.tris.push(new Triangle([
					new Vector3(-0.5, 0.5, -0.5),
					new Vector3(-0.5, 0.5, 0.5),
					new Vector3(0.5, 0.5, 0.5)]));

				this.tris.push(new Triangle([
					new Vector3(-0.5, 0.5, -0.5),
					new Vector3(0.5, 0.5, 0.5),
					new Vector3(0.5, 0.5, -0.5)]));

				// BOTTOM
				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, 0.5),
					new Vector3(-0.5, -0.5, 0.5),
					new Vector3(-0.5, -0.5, -0.5)]));

				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, 0.5),
					new Vector3(-0.5, -0.5, -0.5),
					new Vector3(0.5, -0.5, -0.5)]));
			}

			getTransformTriangles() {
				let transformedTris = [];
				for (let tri of this.tris) {
					let transformedTri = tri.clone();
					transformedTri.mulMat4x4(Mat4x4.Scale(this.scale.x, this.scale.y, this.scale.z));
					transformedTri.mulMat4x4(Mat4x4.RotationX(this.rotation.x));
					transformedTri.mulMat4x4(Mat4x4.RotationY(this.rotation.y));
					transformedTri.mulMat4x4(Mat4x4.RotationZ(this.rotation.z));
					transformedTri.mulMat4x4(Mat4x4.Translation(this.pos.x, this.pos.y, this.pos.z));
					transformedTris.push(transformedTri);
				}
				return transformedTris;
			}
		}


		const canvas = document.getElementById("gameCanvas");
		const ctx = canvas.getContext("2d");
		const fov = 90;
		let znear = 0.01, zfar = 1000;
		let projectionMatrix = Mat4x4.Projection(fov, canvas.height, canvas.width, znear, zfar);

		let cube1 = new Cube(new Vector3(0.6, -0.7, 2.5), new Vector3(45, 0, 0), new Vector3(0.7, 0.7, 0.7));
		let cube2 = new Cube(new Vector3(1, 0, 2.5), new Vector3(0, 0, 15), new Vector3(1, 0.7, 0.7));
		cube2.pos = Vector3.sub(cube2.pos, new Vector3(1.6, 0, 0));

		let lastTime = performance.now();
		let dt = 0;

		function update(time = performance.now()) {
			dt = (time - lastTime) / 1000;
			lastTime = time;

			ctx.clearRect(0, 0, canvas.width, canvas.height);
			cube1.rotation = new Vector3(cube1.rotation.x, cube1.rotation.y + 50 * dt, cube1.rotation.z);
			cube2.rotation = new Vector3(cube2.rotation.x + 50 * dt, cube2.rotation.y, cube2.rotation.z + 50 * dt);

			let allTris = [];
			allTris.push(...cube1.getTransformTriangles());
			allTris.push(...cube2.getTransformTriangles());
			for (let tri of allTris) {
				let vertices = tri.vertices;
				for (let i = 0; i < vertices.length; i++) {
					vertices[i].mulMat4x4(projectionMatrix);
					vertices[i] = Vector3.div(vertices[i], vertices[i].w);
					vertices[i] = new Vector3(
						vertices[i].x * canvas.width + canvas.width / 2,
						-vertices[i].y * canvas.height + canvas.height / 2,
						1);
				}
				ctx.beginPath();
				ctx.moveTo(vertices[0].x, vertices[0].y);
				ctx.lineTo(vertices[1].x, vertices[1].y);
				ctx.lineTo(vertices[2].x, vertices[2].y);
				ctx.closePath();
				ctx.stroke();
			}

			requestAnimationFrame(update);
		}

		update();

	</script>
</body>

</html>