<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<title>3D Engine</title>
</head>

<body style="text-align: center; background: #f0f0f0">
	<h1>3D Engine</h1>
	<canvas id="gameCanvas" width="400" height="300" style="border: 2px solid #aaa; background: #fff"></canvas>
	<h2 id="fps">FPS: 0</h2>
	<script>
		class Vector3 {
			constructor(x = 0, y = 0, z = 0, w = 1) {
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
			}

			clone() {
				return new Vector3(this.x, this.y, this.z, this.w);
			}

			static add(vec1, vec2) {
				return new Vector3(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z);
			}
			static sub(vec1, vec2) {
				return new Vector3(vec1.x - vec2.x, vec1.y - vec2.y, vec1.z - vec2.z);
			}
			static mul(vec, value) {
				return new Vector3(vec.x * value, vec.y * value, vec.z * value);
			}
			static div(vec, value) {
				return new Vector3(vec.x / value, vec.y / value, vec.z / value);
			}
			static scale(vec1, vec2) {
				return new Vector3(vec1.x * vec2.x, vec1.y * vec2.y, vec1.z * vec2.z);
			}
			static dot(v1, v2) {
				return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
			}
			static cross(v1, v2) {
				let v = new Vector3(
					v1.y * v2.z - v1.z * v2.y,
					v1.z * v2.x - v1.x * v2.z,
					v1.x * v2.y - v1.y * v2.x);
				return v;
			}
			magnitude() {
				return Math.hypot(this.x, this.y, this.z);
			}
			normalize() {
				let length = this.magnitude();
				if (length === 0)
					return this;
				this.x /= length;
				this.y /= length;
				this.z /= length;
				return this;
			}

			mulMat4x4(m) {
				let x = this.x;
				let y = this.y;
				let z = this.z;
				let w = this.w;
				this.x = m.m[0][0] * x + m.m[0][1] * y + m.m[0][2] * z + m.m[0][3] * w;
				this.y = m.m[1][0] * x + m.m[1][1] * y + m.m[1][2] * z + m.m[1][3] * w;
				this.z = m.m[2][0] * x + m.m[2][1] * y + m.m[2][2] * z + m.m[2][3] * w;
				this.w = m.m[3][0] * x + m.m[3][1] * y + m.m[3][2] * z + m.m[3][3] * w;
			}
		}

		class Mat4x4 {
			constructor() {
				this.m = [
					[0, 0, 0, 0],
					[0, 0, 0, 0],
					[0, 0, 0, 0],
					[0, 0, 0, 0]
				];
			}
			static Identity;

			static Multiply(m1, m2) {
				let result = new Mat4x4();
				for (let r = 0; r < 4; r++) {
					for (let c = 0; c < 4; c++) {
						result.m[r][c] =
							m1.m[r][0] * m2.m[0][c] +
							m1.m[r][1] * m2.m[1][c] +
							m1.m[r][2] * m2.m[2][c] +
							m1.m[r][3] * m2.m[3][c];
					}
				}
				return result;
			}

			static Projection(fov, h, w, zNear, zFar) {
				let fovMultiplier = 1.0 / Math.tan(fov * 0.5 / 180.0 * Math.PI);
				let matrix = new Mat4x4();
				matrix.m[0][0] = h / w * fovMultiplier;
				matrix.m[1][1] = fovMultiplier;
				matrix.m[2][2] = zFar / (zFar - zNear);
				matrix.m[2][3] = (-zNear * zFar) / (zFar - zNear);
				matrix.m[3][2] = 1.0;
				return matrix;
			}

			static Translation(x, y, z) {
				let matrix = new Mat4x4();
				matrix.m[0][0] = 1;
				matrix.m[1][1] = 1;
				matrix.m[2][2] = 1;
				matrix.m[3][3] = 1;
				matrix.m[0][3] = x;
				matrix.m[1][3] = y;
				matrix.m[2][3] = z;
				return matrix;
			}

			static Scale(x, y, z) {
				let matrix = new Mat4x4();
				matrix.m[0][0] = x;
				matrix.m[1][1] = y;
				matrix.m[2][2] = z;
				matrix.m[3][3] = 1;
				return matrix;
			}

			static RotationX(angle) {
				let radian = angle / 180.0 * Math.PI;
				let matrix = new Mat4x4();
				matrix.m[0][0] = 1;
				matrix.m[1][1] = Math.cos(radian);
				matrix.m[1][2] = Math.sin(radian);
				matrix.m[2][1] = -Math.sin(radian);
				matrix.m[2][2] = Math.cos(radian);
				matrix.m[3][3] = 1;
				return matrix;
			}

			static RotationY(angle) {
				let radian = angle / 180.0 * Math.PI;
				let matrix = new Mat4x4();
				matrix.m[0][0] = Math.cos(radian);
				matrix.m[0][2] = -Math.sin(radian);
				matrix.m[1][1] = 1;
				matrix.m[2][0] = Math.sin(radian);
				matrix.m[2][2] = Math.cos(radian);
				matrix.m[3][3] = 1;
				return matrix;
			}

			static RotationZ(angle) {
				let radian = angle / 180.0 * Math.PI;
				let matrix = new Mat4x4();
				matrix.m[0][0] = Math.cos(radian);
				matrix.m[0][1] = Math.sin(radian);
				matrix.m[1][0] = -Math.sin(radian);
				matrix.m[1][1] = Math.cos(radian);
				matrix.m[2][2] = 1;
				matrix.m[3][3] = 1;
				return matrix;
			}
		}
		Mat4x4.Identity = new Mat4x4();
		Mat4x4.Identity.m[0][0] = 1;
		Mat4x4.Identity.m[1][1] = 1;
		Mat4x4.Identity.m[2][2] = 1;
		Mat4x4.Identity.m[3][3] = 1;

		class Triangle {
			constructor(vertices = []) {
				if (vertices.length == 0) {
					this.vertices = [];
					for (let i = 0; i < 3; i++) {
						this.vertices.push(new Vector3(0, 0, 0));
					}
				} else {
					this.vertices = vertices;
				}
			}

			clone() {
				let tri = new Triangle();
				for (let i = 0; i < this.vertices.length; i++)
					tri.vertices[i] = this.vertices[i].clone();
				return tri;
			}

			mulMat4x4(m) {
				for (let v of this.vertices) {
					v.mulMat4x4(m);
				}
			}

			getCenter() {
				let x = (this.vertices[0].x + this.vertices[1].x + this.vertices[2].x) / 3.0;
				let y = (this.vertices[0].y + this.vertices[1].y + this.vertices[2].y) / 3.0;
				let z = (this.vertices[0].z + this.vertices[1].z + this.vertices[2].z) / 3.0;
				return new Vector3(x, y, z);
			}

			getNormal() {
				let v1 = Vector3.sub(this.vertices[0], this.vertices[1]);
				let v2 = Vector3.sub(this.vertices[1], this.vertices[2]);
				let normal = Vector3.cross(v1, v2);
				normal.normalize();
				return normal;
			}
		}

		class Cube {
			constructor(pos, rotation, scale) {
				this.tris = [];
				this.pos = pos;
				this.scale = scale;

				this.rotationMatrix = Mat4x4.Multiply(Mat4x4.RotationX(rotation.x), Mat4x4.Identity);
				this.rotateY(rotation.y);
				this.rotateZ(rotation.z);

				this.generateInitialTriangles();
			}

			generateInitialTriangles() {
				// FRONT
				this.tris.push(new Triangle([
					new Vector3(-0.5, -0.5, -0.5),
					new Vector3(-0.5, 0.5, -0.5),
					new Vector3(0.5, 0.5, -0.5)]));
				this.tris.push(new Triangle([
					new Vector3(-0.5, -0.5, -0.5),
					new Vector3(0.5, 0.5, -0.5),
					new Vector3(0.5, -0.5, -0.5)]));

				// RIGHT
				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, -0.5),
					new Vector3(0.5, 0.5, -0.5),
					new Vector3(0.5, 0.5, 0.5)]));

				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, -0.5),
					new Vector3(0.5, 0.5, 0.5),
					new Vector3(0.5, -0.5, 0.5)]));

				// BACK
				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, 0.5),
					new Vector3(0.5, 0.5, 0.5),
					new Vector3(-0.5, 0.5, 0.5)]));

				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, 0.5),
					new Vector3(-0.5, 0.5, 0.5),
					new Vector3(-0.5, -0.5, 0.5)]));

				// LEFT
				this.tris.push(new Triangle([
					new Vector3(-0.5, -0.5, 0.5),
					new Vector3(-0.5, 0.5, 0.5),
					new Vector3(-0.5, 0.5, -0.5)]));

				this.tris.push(new Triangle([
					new Vector3(-0.5, -0.5, 0.5),
					new Vector3(-0.5, 0.5, -0.5),
					new Vector3(-0.5, -0.5, -0.5)]));

				// TOP
				this.tris.push(new Triangle([
					new Vector3(-0.5, 0.5, -0.5),
					new Vector3(-0.5, 0.5, 0.5),
					new Vector3(0.5, 0.5, 0.5)]));

				this.tris.push(new Triangle([
					new Vector3(-0.5, 0.5, -0.5),
					new Vector3(0.5, 0.5, 0.5),
					new Vector3(0.5, 0.5, -0.5)]));

				// BOTTOM
				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, 0.5),
					new Vector3(-0.5, -0.5, 0.5),
					new Vector3(-0.5, -0.5, -0.5)]));

				this.tris.push(new Triangle([
					new Vector3(0.5, -0.5, 0.5),
					new Vector3(-0.5, -0.5, -0.5),
					new Vector3(0.5, -0.5, -0.5)]));
			}

			rotateX(angle) {
				this.rotationMatrix = Mat4x4.Multiply(Mat4x4.RotationX(angle), this.rotationMatrix);
			}
			rotateY(angle) {
				this.rotationMatrix = Mat4x4.Multiply(Mat4x4.RotationY(angle), this.rotationMatrix);
			}
			rotateZ(angle) {
				this.rotationMatrix = Mat4x4.Multiply(Mat4x4.RotationZ(angle), this.rotationMatrix);
			}

			getTransformedTriangles() {
				let transformedTris = [];
				for (let tri of this.tris) {
					let transformedTri = tri.clone();
					transformedTri.mulMat4x4(Mat4x4.Scale(this.scale.x, this.scale.y, this.scale.z));
					transformedTri.mulMat4x4(this.rotationMatrix);
					transformedTri.mulMat4x4(Mat4x4.Translation(this.pos.x, this.pos.y, this.pos.z));
					transformedTris.push(transformedTri);
				}
				return transformedTris;
			}
		}


		const canvas = document.getElementById("gameCanvas");
		const ctx = canvas.getContext("2d");
		const fov = 90;
		let znear = 0.01, zfar = 1000;
		let projectionMatrix = Mat4x4.Projection(fov, canvas.height, canvas.width, znear, zfar);
		let cameraPos = new Vector3(0, 0, 0);

		const fpsInfo = document.getElementById("fps");
		let frames = 0, fpsTimeCounter = 0;

		let cube1 = new Cube(new Vector3(0.6, -0.7, 2.5), new Vector3(45, 0, 0), new Vector3(0.7, 0.7, 0.7));
		let cube2 = new Cube(new Vector3(1, 0, 2.5), new Vector3(0, 0, 15), new Vector3(1, 0.7, 0.7));
		cube2.pos = Vector3.sub(cube2.pos, new Vector3(1.6, 0, 0));

		let lastTime = performance.now();
		let dt = 0;

		function update(time = performance.now()) {
			dt = (time - lastTime) / 1000;
			lastTime = time;

			fpsTimeCounter += dt;
			frames++;
			if (fpsTimeCounter >= 1) {
				fpsInfo.textContent = `FPS: ${frames}`;
				frames = 0;
				fpsTimeCounter = 0;
			}

			ctx.clearRect(0, 0, canvas.width, canvas.height);
			cube1.rotateY(50 * dt);
			cube2.rotateX(50 * dt);

			let allTris = [];
			allTris.push(...cube1.getTransformedTriangles());
			allTris.push(...cube2.getTransformedTriangles());
			for (let tri of allTris) {
				if (Vector3.dot(tri.getNormal(), Vector3.sub(tri.getCenter(), cameraPos)) < 0) {
					let vertices = tri.vertices;
					for (let i = 0; i < vertices.length; i++) {
						vertices[i].mulMat4x4(projectionMatrix);
						vertices[i] = Vector3.div(vertices[i], vertices[i].w);
						vertices[i] = new Vector3(
							vertices[i].x * canvas.width + canvas.width / 2,
							-vertices[i].y * canvas.height + canvas.height / 2,
							1);
					}
					ctx.beginPath();
					ctx.moveTo(vertices[0].x, vertices[0].y);
					ctx.lineTo(vertices[1].x, vertices[1].y);
					ctx.lineTo(vertices[2].x, vertices[2].y);
					ctx.closePath();
					ctx.stroke();
				}
			}

			requestAnimationFrame(update);
		}

		update();

	</script>
</body>

</html>